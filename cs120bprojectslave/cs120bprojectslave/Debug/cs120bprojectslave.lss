
cs120bprojectslave.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  0000062e  000006c2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000062e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000064  00800104  00800104  000006c6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000006c6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000006f8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000e8  00000000  00000000  00000738  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000097e  00000000  00000000  00000820  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002a1  00000000  00000000  0000119e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000007db  00000000  00000000  0000143f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000260  00000000  00000000  00001c1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004df  00000000  00000000  00001e7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000a15  00000000  00000000  0000235b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d8  00000000  00000000  00002d70  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	4f c0       	rjmp	.+158    	; 0xa0 <__ctors_end>
   2:	00 00       	nop
   4:	6a c0       	rjmp	.+212    	; 0xda <__bad_interrupt>
   6:	00 00       	nop
   8:	68 c0       	rjmp	.+208    	; 0xda <__bad_interrupt>
   a:	00 00       	nop
   c:	66 c0       	rjmp	.+204    	; 0xda <__bad_interrupt>
   e:	00 00       	nop
  10:	64 c0       	rjmp	.+200    	; 0xda <__bad_interrupt>
  12:	00 00       	nop
  14:	62 c0       	rjmp	.+196    	; 0xda <__bad_interrupt>
  16:	00 00       	nop
  18:	60 c0       	rjmp	.+192    	; 0xda <__bad_interrupt>
  1a:	00 00       	nop
  1c:	5e c0       	rjmp	.+188    	; 0xda <__bad_interrupt>
  1e:	00 00       	nop
  20:	5c c0       	rjmp	.+184    	; 0xda <__bad_interrupt>
  22:	00 00       	nop
  24:	5a c0       	rjmp	.+180    	; 0xda <__bad_interrupt>
  26:	00 00       	nop
  28:	58 c0       	rjmp	.+176    	; 0xda <__bad_interrupt>
  2a:	00 00       	nop
  2c:	56 c0       	rjmp	.+172    	; 0xda <__bad_interrupt>
  2e:	00 00       	nop
  30:	54 c0       	rjmp	.+168    	; 0xda <__bad_interrupt>
  32:	00 00       	nop
  34:	2c c1       	rjmp	.+600    	; 0x28e <__vector_13>
  36:	00 00       	nop
  38:	50 c0       	rjmp	.+160    	; 0xda <__bad_interrupt>
  3a:	00 00       	nop
  3c:	4e c0       	rjmp	.+156    	; 0xda <__bad_interrupt>
  3e:	00 00       	nop
  40:	4c c0       	rjmp	.+152    	; 0xda <__bad_interrupt>
  42:	00 00       	nop
  44:	4a c0       	rjmp	.+148    	; 0xda <__bad_interrupt>
  46:	00 00       	nop
  48:	48 c0       	rjmp	.+144    	; 0xda <__bad_interrupt>
  4a:	00 00       	nop
  4c:	46 c0       	rjmp	.+140    	; 0xda <__bad_interrupt>
  4e:	00 00       	nop
  50:	44 c0       	rjmp	.+136    	; 0xda <__bad_interrupt>
  52:	00 00       	nop
  54:	42 c0       	rjmp	.+132    	; 0xda <__bad_interrupt>
  56:	00 00       	nop
  58:	40 c0       	rjmp	.+128    	; 0xda <__bad_interrupt>
  5a:	00 00       	nop
  5c:	3e c0       	rjmp	.+124    	; 0xda <__bad_interrupt>
  5e:	00 00       	nop
  60:	3c c0       	rjmp	.+120    	; 0xda <__bad_interrupt>
  62:	00 00       	nop
  64:	3a c0       	rjmp	.+116    	; 0xda <__bad_interrupt>
  66:	00 00       	nop
  68:	38 c0       	rjmp	.+112    	; 0xda <__bad_interrupt>
  6a:	00 00       	nop
  6c:	36 c0       	rjmp	.+108    	; 0xda <__bad_interrupt>
  6e:	00 00       	nop
  70:	34 c0       	rjmp	.+104    	; 0xda <__bad_interrupt>
  72:	00 00       	nop
  74:	32 c0       	rjmp	.+100    	; 0xda <__bad_interrupt>
  76:	00 00       	nop
  78:	30 c0       	rjmp	.+96     	; 0xda <__bad_interrupt>
  7a:	00 00       	nop
  7c:	2e c0       	rjmp	.+92     	; 0xda <__bad_interrupt>
  7e:	00 00       	nop
  80:	2c c0       	rjmp	.+88     	; 0xda <__bad_interrupt>
  82:	00 00       	nop
  84:	2a c0       	rjmp	.+84     	; 0xda <__bad_interrupt>
  86:	00 00       	nop
  88:	28 c0       	rjmp	.+80     	; 0xda <__bad_interrupt>
  8a:	00 00       	nop
  8c:	2c 02       	muls	r18, r28
  8e:	18 02       	muls	r17, r24
  90:	1a 02       	muls	r17, r26
  92:	1c 02       	muls	r17, r28
  94:	1e 02       	muls	r17, r30
  96:	20 02       	muls	r18, r16
  98:	22 02       	muls	r18, r18
  9a:	24 02       	muls	r18, r20
  9c:	26 02       	muls	r18, r22
  9e:	28 02       	muls	r18, r24

000000a0 <__ctors_end>:
  a0:	11 24       	eor	r1, r1
  a2:	1f be       	out	0x3f, r1	; 63
  a4:	cf ef       	ldi	r28, 0xFF	; 255
  a6:	d0 e4       	ldi	r29, 0x40	; 64
  a8:	de bf       	out	0x3e, r29	; 62
  aa:	cd bf       	out	0x3d, r28	; 61

000000ac <__do_copy_data>:
  ac:	11 e0       	ldi	r17, 0x01	; 1
  ae:	a0 e0       	ldi	r26, 0x00	; 0
  b0:	b1 e0       	ldi	r27, 0x01	; 1
  b2:	ee e2       	ldi	r30, 0x2E	; 46
  b4:	f6 e0       	ldi	r31, 0x06	; 6
  b6:	00 e0       	ldi	r16, 0x00	; 0
  b8:	0b bf       	out	0x3b, r16	; 59
  ba:	02 c0       	rjmp	.+4      	; 0xc0 <__do_copy_data+0x14>
  bc:	07 90       	elpm	r0, Z+
  be:	0d 92       	st	X+, r0
  c0:	a4 30       	cpi	r26, 0x04	; 4
  c2:	b1 07       	cpc	r27, r17
  c4:	d9 f7       	brne	.-10     	; 0xbc <__do_copy_data+0x10>

000000c6 <__do_clear_bss>:
  c6:	21 e0       	ldi	r18, 0x01	; 1
  c8:	a4 e0       	ldi	r26, 0x04	; 4
  ca:	b1 e0       	ldi	r27, 0x01	; 1
  cc:	01 c0       	rjmp	.+2      	; 0xd0 <.do_clear_bss_start>

000000ce <.do_clear_bss_loop>:
  ce:	1d 92       	st	X+, r1

000000d0 <.do_clear_bss_start>:
  d0:	a8 36       	cpi	r26, 0x68	; 104
  d2:	b2 07       	cpc	r27, r18
  d4:	e1 f7       	brne	.-8      	; 0xce <.do_clear_bss_loop>
  d6:	f7 d1       	rcall	.+1006   	; 0x4c6 <main>
  d8:	a8 c2       	rjmp	.+1360   	; 0x62a <_exit>

000000da <__bad_interrupt>:
  da:	92 cf       	rjmp	.-220    	; 0x0 <__vectors>

000000dc <TickFct_Joystick>:
	}
}

void TimerSet(unsigned long M) {
	_avr_timer_M = M;
	_avr_timer_cntcurr = _avr_timer_M;
  dc:	00 97       	sbiw	r24, 0x00	; 0
  de:	d9 f0       	breq	.+54     	; 0x116 <TickFct_Joystick+0x3a>
  e0:	81 30       	cpi	r24, 0x01	; 1
  e2:	91 05       	cpc	r25, r1
  e4:	19 f0       	breq	.+6      	; 0xec <TickFct_Joystick+0x10>
  e6:	80 e0       	ldi	r24, 0x00	; 0
  e8:	90 e0       	ldi	r25, 0x00	; 0
  ea:	08 95       	ret
  ec:	20 91 78 00 	lds	r18, 0x0078
  f0:	30 91 79 00 	lds	r19, 0x0079
  f4:	29 35       	cpi	r18, 0x59	; 89
  f6:	32 40       	sbci	r19, 0x02	; 2
  f8:	18 f0       	brcs	.+6      	; 0x100 <TickFct_Joystick+0x24>
  fa:	21 e0       	ldi	r18, 0x01	; 1
  fc:	20 93 0d 01 	sts	0x010D, r18
 100:	20 91 78 00 	lds	r18, 0x0078
 104:	30 91 79 00 	lds	r19, 0x0079
 108:	20 39       	cpi	r18, 0x90	; 144
 10a:	31 40       	sbci	r19, 0x01	; 1
 10c:	30 f4       	brcc	.+12     	; 0x11a <TickFct_Joystick+0x3e>
 10e:	21 e0       	ldi	r18, 0x01	; 1
 110:	20 93 0e 01 	sts	0x010E, r18
 114:	08 95       	ret
 116:	81 e0       	ldi	r24, 0x01	; 1
 118:	90 e0       	ldi	r25, 0x00	; 0
 11a:	08 95       	ret

0000011c <TickFct_Crouch>:
 11c:	00 97       	sbiw	r24, 0x00	; 0
 11e:	61 f0       	breq	.+24     	; 0x138 <TickFct_Crouch+0x1c>
 120:	81 30       	cpi	r24, 0x01	; 1
 122:	91 05       	cpc	r25, r1
 124:	19 f0       	breq	.+6      	; 0x12c <TickFct_Crouch+0x10>
 126:	80 e0       	ldi	r24, 0x00	; 0
 128:	90 e0       	ldi	r25, 0x00	; 0
 12a:	08 95       	ret
 12c:	01 99       	sbic	0x00, 1	; 0
 12e:	06 c0       	rjmp	.+12     	; 0x13c <TickFct_Crouch+0x20>
 130:	21 e0       	ldi	r18, 0x01	; 1
 132:	20 93 0a 01 	sts	0x010A, r18
 136:	08 95       	ret
 138:	81 e0       	ldi	r24, 0x01	; 1
 13a:	90 e0       	ldi	r25, 0x00	; 0
 13c:	08 95       	ret

0000013e <TickFct_Jump>:
 13e:	00 97       	sbiw	r24, 0x00	; 0
 140:	61 f0       	breq	.+24     	; 0x15a <TickFct_Jump+0x1c>
 142:	81 30       	cpi	r24, 0x01	; 1
 144:	91 05       	cpc	r25, r1
 146:	19 f0       	breq	.+6      	; 0x14e <TickFct_Jump+0x10>
 148:	80 e0       	ldi	r24, 0x00	; 0
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	08 95       	ret
 14e:	02 99       	sbic	0x00, 2	; 0
 150:	06 c0       	rjmp	.+12     	; 0x15e <TickFct_Jump+0x20>
 152:	21 e0       	ldi	r18, 0x01	; 1
 154:	20 93 0b 01 	sts	0x010B, r18
 158:	08 95       	ret
 15a:	81 e0       	ldi	r24, 0x01	; 1
 15c:	90 e0       	ldi	r25, 0x00	; 0
 15e:	08 95       	ret

00000160 <TickFct_Reset>:
 160:	00 97       	sbiw	r24, 0x00	; 0
 162:	61 f0       	breq	.+24     	; 0x17c <TickFct_Reset+0x1c>
 164:	81 30       	cpi	r24, 0x01	; 1
 166:	91 05       	cpc	r25, r1
 168:	19 f0       	breq	.+6      	; 0x170 <TickFct_Reset+0x10>
 16a:	80 e0       	ldi	r24, 0x00	; 0
 16c:	90 e0       	ldi	r25, 0x00	; 0
 16e:	08 95       	ret
 170:	03 99       	sbic	0x00, 3	; 0
 172:	06 c0       	rjmp	.+12     	; 0x180 <TickFct_Reset+0x20>
 174:	21 e0       	ldi	r18, 0x01	; 1
 176:	20 93 0c 01 	sts	0x010C, r18
 17a:	08 95       	ret
 17c:	81 e0       	ldi	r24, 0x01	; 1
 17e:	90 e0       	ldi	r25, 0x00	; 0
 180:	08 95       	ret

00000182 <TickFct_Motor>:
 182:	00 97       	sbiw	r24, 0x00	; 0
 184:	c9 f0       	breq	.+50     	; 0x1b8 <TickFct_Motor+0x36>
 186:	81 30       	cpi	r24, 0x01	; 1
 188:	91 05       	cpc	r25, r1
 18a:	19 f0       	breq	.+6      	; 0x192 <TickFct_Motor+0x10>
 18c:	80 e0       	ldi	r24, 0x00	; 0
 18e:	90 e0       	ldi	r25, 0x00	; 0
 190:	08 95       	ret
 192:	20 91 09 01 	lds	r18, 0x0109
 196:	22 23       	and	r18, r18
 198:	21 f0       	breq	.+8      	; 0x1a2 <TickFct_Motor+0x20>
 19a:	10 92 09 01 	sts	0x0109, r1
 19e:	2e e1       	ldi	r18, 0x1E	; 30
 1a0:	04 c0       	rjmp	.+8      	; 0x1aa <TickFct_Motor+0x28>
 1a2:	20 91 05 01 	lds	r18, 0x0105
 1a6:	22 23       	and	r18, r18
 1a8:	29 f0       	breq	.+10     	; 0x1b4 <TickFct_Motor+0x32>
 1aa:	21 50       	subi	r18, 0x01	; 1
 1ac:	20 93 05 01 	sts	0x0105, r18
 1b0:	40 98       	cbi	0x08, 0	; 8
 1b2:	08 95       	ret
 1b4:	40 9a       	sbi	0x08, 0	; 8
 1b6:	08 95       	ret
 1b8:	81 e0       	ldi	r24, 0x01	; 1
 1ba:	90 e0       	ldi	r25, 0x00	; 0
 1bc:	08 95       	ret

000001be <ADC_init>:
 1be:	ea e7       	ldi	r30, 0x7A	; 122
 1c0:	f0 e0       	ldi	r31, 0x00	; 0
 1c2:	80 81       	ld	r24, Z
 1c4:	80 6e       	ori	r24, 0xE0	; 224
 1c6:	80 83       	st	Z, r24
 1c8:	08 95       	ret

000001ca <TimerOn>:
 1ca:	8b e0       	ldi	r24, 0x0B	; 11
 1cc:	80 93 81 00 	sts	0x0081, r24
 1d0:	8d e7       	ldi	r24, 0x7D	; 125
 1d2:	90 e0       	ldi	r25, 0x00	; 0
 1d4:	90 93 89 00 	sts	0x0089, r25
 1d8:	80 93 88 00 	sts	0x0088, r24
 1dc:	82 e0       	ldi	r24, 0x02	; 2
 1de:	80 93 6f 00 	sts	0x006F, r24
 1e2:	10 92 85 00 	sts	0x0085, r1
 1e6:	10 92 84 00 	sts	0x0084, r1
 1ea:	80 91 00 01 	lds	r24, 0x0100
 1ee:	90 91 01 01 	lds	r25, 0x0101
 1f2:	a0 91 02 01 	lds	r26, 0x0102
 1f6:	b0 91 03 01 	lds	r27, 0x0103
 1fa:	80 93 0f 01 	sts	0x010F, r24
 1fe:	90 93 10 01 	sts	0x0110, r25
 202:	a0 93 11 01 	sts	0x0111, r26
 206:	b0 93 12 01 	sts	0x0112, r27
 20a:	8f b7       	in	r24, 0x3f	; 63
 20c:	80 68       	ori	r24, 0x80	; 128
 20e:	8f bf       	out	0x3f, r24	; 63
 210:	08 95       	ret

00000212 <TimerISR>:
 212:	ef 92       	push	r14
 214:	ff 92       	push	r15
 216:	0f 93       	push	r16
 218:	1f 93       	push	r17
 21a:	cf 93       	push	r28
 21c:	df 93       	push	r29
 21e:	c4 e1       	ldi	r28, 0x14	; 20
 220:	d1 e0       	ldi	r29, 0x01	; 1
 222:	0f 2e       	mov	r0, r31
 224:	f8 e6       	ldi	r31, 0x68	; 104
 226:	ef 2e       	mov	r14, r31
 228:	f1 e0       	ldi	r31, 0x01	; 1
 22a:	ff 2e       	mov	r15, r31
 22c:	f0 2d       	mov	r31, r0
 22e:	8e 01       	movw	r16, r28
 230:	4e 81       	ldd	r20, Y+6	; 0x06
 232:	5f 81       	ldd	r21, Y+7	; 0x07
 234:	68 85       	ldd	r22, Y+8	; 0x08
 236:	79 85       	ldd	r23, Y+9	; 0x09
 238:	8a 81       	ldd	r24, Y+2	; 0x02
 23a:	9b 81       	ldd	r25, Y+3	; 0x03
 23c:	ac 81       	ldd	r26, Y+4	; 0x04
 23e:	bd 81       	ldd	r27, Y+5	; 0x05
 240:	48 17       	cp	r20, r24
 242:	59 07       	cpc	r21, r25
 244:	6a 07       	cpc	r22, r26
 246:	7b 07       	cpc	r23, r27
 248:	58 f0       	brcs	.+22     	; 0x260 <TimerISR+0x4e>
 24a:	ea 85       	ldd	r30, Y+10	; 0x0a
 24c:	fb 85       	ldd	r31, Y+11	; 0x0b
 24e:	88 81       	ld	r24, Y
 250:	99 81       	ldd	r25, Y+1	; 0x01
 252:	09 95       	icall
 254:	99 83       	std	Y+1, r25	; 0x01
 256:	88 83       	st	Y, r24
 258:	1e 82       	std	Y+6, r1	; 0x06
 25a:	1f 82       	std	Y+7, r1	; 0x07
 25c:	18 86       	std	Y+8, r1	; 0x08
 25e:	19 86       	std	Y+9, r1	; 0x09
 260:	f8 01       	movw	r30, r16
 262:	86 81       	ldd	r24, Z+6	; 0x06
 264:	97 81       	ldd	r25, Z+7	; 0x07
 266:	a0 85       	ldd	r26, Z+8	; 0x08
 268:	b1 85       	ldd	r27, Z+9	; 0x09
 26a:	01 96       	adiw	r24, 0x01	; 1
 26c:	a1 1d       	adc	r26, r1
 26e:	b1 1d       	adc	r27, r1
 270:	86 83       	std	Z+6, r24	; 0x06
 272:	97 83       	std	Z+7, r25	; 0x07
 274:	a0 87       	std	Z+8, r26	; 0x08
 276:	b1 87       	std	Z+9, r27	; 0x09
 278:	2c 96       	adiw	r28, 0x0c	; 12
 27a:	ce 15       	cp	r28, r14
 27c:	df 05       	cpc	r29, r15
 27e:	b9 f6       	brne	.-82     	; 0x22e <TimerISR+0x1c>
 280:	df 91       	pop	r29
 282:	cf 91       	pop	r28
 284:	1f 91       	pop	r17
 286:	0f 91       	pop	r16
 288:	ff 90       	pop	r15
 28a:	ef 90       	pop	r14
 28c:	08 95       	ret

0000028e <__vector_13>:
 28e:	1f 92       	push	r1
 290:	0f 92       	push	r0
 292:	0f b6       	in	r0, 0x3f	; 63
 294:	0f 92       	push	r0
 296:	11 24       	eor	r1, r1
 298:	0b b6       	in	r0, 0x3b	; 59
 29a:	0f 92       	push	r0
 29c:	2f 93       	push	r18
 29e:	3f 93       	push	r19
 2a0:	4f 93       	push	r20
 2a2:	5f 93       	push	r21
 2a4:	6f 93       	push	r22
 2a6:	7f 93       	push	r23
 2a8:	8f 93       	push	r24
 2aa:	9f 93       	push	r25
 2ac:	af 93       	push	r26
 2ae:	bf 93       	push	r27
 2b0:	ef 93       	push	r30
 2b2:	ff 93       	push	r31
 2b4:	80 91 0f 01 	lds	r24, 0x010F
 2b8:	90 91 10 01 	lds	r25, 0x0110
 2bc:	a0 91 11 01 	lds	r26, 0x0111
 2c0:	b0 91 12 01 	lds	r27, 0x0112
 2c4:	01 97       	sbiw	r24, 0x01	; 1
 2c6:	a1 09       	sbc	r26, r1
 2c8:	b1 09       	sbc	r27, r1
 2ca:	80 93 0f 01 	sts	0x010F, r24
 2ce:	90 93 10 01 	sts	0x0110, r25
 2d2:	a0 93 11 01 	sts	0x0111, r26
 2d6:	b0 93 12 01 	sts	0x0112, r27
 2da:	89 2b       	or	r24, r25
 2dc:	8a 2b       	or	r24, r26
 2de:	8b 2b       	or	r24, r27
 2e0:	89 f4       	brne	.+34     	; 0x304 <__vector_13+0x76>
 2e2:	97 df       	rcall	.-210    	; 0x212 <TimerISR>
 2e4:	80 91 00 01 	lds	r24, 0x0100
 2e8:	90 91 01 01 	lds	r25, 0x0101
 2ec:	a0 91 02 01 	lds	r26, 0x0102
 2f0:	b0 91 03 01 	lds	r27, 0x0103
 2f4:	80 93 0f 01 	sts	0x010F, r24
 2f8:	90 93 10 01 	sts	0x0110, r25
 2fc:	a0 93 11 01 	sts	0x0111, r26
 300:	b0 93 12 01 	sts	0x0112, r27
 304:	ff 91       	pop	r31
 306:	ef 91       	pop	r30
 308:	bf 91       	pop	r27
 30a:	af 91       	pop	r26
 30c:	9f 91       	pop	r25
 30e:	8f 91       	pop	r24
 310:	7f 91       	pop	r23
 312:	6f 91       	pop	r22
 314:	5f 91       	pop	r21
 316:	4f 91       	pop	r20
 318:	3f 91       	pop	r19
 31a:	2f 91       	pop	r18
 31c:	0f 90       	pop	r0
 31e:	0b be       	out	0x3b, r0	; 59
 320:	0f 90       	pop	r0
 322:	0f be       	out	0x3f, r0	; 63
 324:	0f 90       	pop	r0
 326:	1f 90       	pop	r1
 328:	18 95       	reti

0000032a <SPI_SlaveInit>:
}

//SPI
void SPI_SlaveInit(void) {
	DDRB = (1<<DDB6);
 32a:	80 e4       	ldi	r24, 0x40	; 64
 32c:	84 b9       	out	0x04, r24	; 4
	SPCR = (1<<SPE);
 32e:	8c bd       	out	0x2c, r24	; 44
 330:	08 95       	ret

00000332 <SPI_Transmit>:
}

unsigned char SPI_Transmit(unsigned char data){
	SPDR = data;
 332:	8e bd       	out	0x2e, r24	; 46
	while( !(SPSR & (1<<SPIF) ));
 334:	0d b4       	in	r0, 0x2d	; 45
 336:	07 fe       	sbrs	r0, 7
 338:	fd cf       	rjmp	.-6      	; 0x334 <SPI_Transmit+0x2>
	return SPDR;
 33a:	8e b5       	in	r24, 0x2e	; 46
}
 33c:	08 95       	ret

0000033e <TickFct_Transmission>:
	}

	return state;
}

int TickFct_Transmission(int state){
 33e:	cf 93       	push	r28
 340:	df 93       	push	r29
 342:	ec 01       	movw	r28, r24
	
	unsigned char dataIn = 0;
	unsigned char dataOut = 0;

	switch(state){	//Transitions
 344:	00 97       	sbiw	r24, 0x00	; 0
 346:	09 f4       	brne	.+2      	; 0x34a <TickFct_Transmission+0xc>
 348:	4c c0       	rjmp	.+152    	; 0x3e2 <TickFct_Transmission+0xa4>
 34a:	01 97       	sbiw	r24, 0x01	; 1
 34c:	19 f0       	breq	.+6      	; 0x354 <TickFct_Transmission+0x16>
			scoreReset = 1;
		}
		break;

		default:
		state = TN_SMStart;
 34e:	c0 e0       	ldi	r28, 0x00	; 0
 350:	d0 e0       	ldi	r29, 0x00	; 0
 352:	49 c0       	rjmp	.+146    	; 0x3e6 <TickFct_Transmission+0xa8>
		//third bit is crouch.
		//fourth bit is jump.
		//fifth bit is reset.
		//sixth bit is win.

		if(rightFlag){
 354:	80 91 0d 01 	lds	r24, 0x010D
 358:	88 23       	and	r24, r24
 35a:	21 f0       	breq	.+8      	; 0x364 <TickFct_Transmission+0x26>
			rightFlag = 0;
 35c:	10 92 0d 01 	sts	0x010D, r1
			dataOut = dataOut | 0x01;
 360:	81 e0       	ldi	r24, 0x01	; 1
 362:	01 c0       	rjmp	.+2      	; 0x366 <TickFct_Transmission+0x28>
}

int TickFct_Transmission(int state){
	
	unsigned char dataIn = 0;
	unsigned char dataOut = 0;
 364:	80 e0       	ldi	r24, 0x00	; 0

		if(rightFlag){
			rightFlag = 0;
			dataOut = dataOut | 0x01;
		}
		if(leftFlag){
 366:	90 91 0e 01 	lds	r25, 0x010E
 36a:	99 23       	and	r25, r25
 36c:	19 f0       	breq	.+6      	; 0x374 <TickFct_Transmission+0x36>
			leftFlag = 0;
 36e:	10 92 0e 01 	sts	0x010E, r1
			dataOut = dataOut | 0x02;
 372:	82 60       	ori	r24, 0x02	; 2
		}
		if(crouchFlag){
 374:	90 91 0a 01 	lds	r25, 0x010A
 378:	99 23       	and	r25, r25
 37a:	19 f0       	breq	.+6      	; 0x382 <TickFct_Transmission+0x44>
			crouchFlag = 0;
 37c:	10 92 0a 01 	sts	0x010A, r1
			dataOut = dataOut | 0x04;
 380:	84 60       	ori	r24, 0x04	; 4
		}
		if(jumpFlag){
 382:	90 91 0b 01 	lds	r25, 0x010B
 386:	99 23       	and	r25, r25
 388:	19 f0       	breq	.+6      	; 0x390 <TickFct_Transmission+0x52>
			jumpFlag = 0;
 38a:	10 92 0b 01 	sts	0x010B, r1
			dataOut = dataOut | 0x08;
 38e:	88 60       	ori	r24, 0x08	; 8
		}
		if(resetFlag){
 390:	90 91 0c 01 	lds	r25, 0x010C
 394:	99 23       	and	r25, r25
 396:	31 f0       	breq	.+12     	; 0x3a4 <TickFct_Transmission+0x66>
			resetFlag = 0;
 398:	10 92 0c 01 	sts	0x010C, r1
			scoreReset = 1;
 39c:	91 e0       	ldi	r25, 0x01	; 1
 39e:	90 93 06 01 	sts	0x0106, r25
			dataOut = dataOut | 0x10;
 3a2:	80 61       	ori	r24, 0x10	; 16
		}
		if(winFlag){
 3a4:	90 91 07 01 	lds	r25, 0x0107
 3a8:	99 23       	and	r25, r25
 3aa:	19 f0       	breq	.+6      	; 0x3b2 <TickFct_Transmission+0x74>
			winFlag = 0;
 3ac:	10 92 07 01 	sts	0x0107, r1
			dataOut = dataOut | 0x20;
 3b0:	80 62       	ori	r24, 0x20	; 32
		}

		dataIn = SPI_Transmit(dataOut);
 3b2:	bf df       	rcall	.-130    	; 0x332 <SPI_Transmit>

		if((dataIn&0x01)==0x01){
 3b4:	80 ff       	sbrs	r24, 0
 3b6:	03 c0       	rjmp	.+6      	; 0x3be <TickFct_Transmission+0x80>
			motorFlag = 1;
 3b8:	91 e0       	ldi	r25, 0x01	; 1
 3ba:	90 93 09 01 	sts	0x0109, r25
		}

		if((dataIn&0x02)==0x02){
 3be:	81 ff       	sbrs	r24, 1
 3c0:	05 c0       	rjmp	.+10     	; 0x3cc <TickFct_Transmission+0x8e>
			scoreFlag = 1;
 3c2:	91 e0       	ldi	r25, 0x01	; 1
 3c4:	90 93 08 01 	sts	0x0108, r25
			motorFlag = 1;
 3c8:	90 93 09 01 	sts	0x0109, r25
		}

		if((dataIn&0x04)==0x04){
 3cc:	82 ff       	sbrs	r24, 2
 3ce:	03 c0       	rjmp	.+6      	; 0x3d6 <TickFct_Transmission+0x98>
			scoreReset = 1;
 3d0:	91 e0       	ldi	r25, 0x01	; 1
 3d2:	90 93 06 01 	sts	0x0106, r25
		}

		if((dataIn&0x08)==0x08){
 3d6:	83 ff       	sbrs	r24, 3
 3d8:	06 c0       	rjmp	.+12     	; 0x3e6 <TickFct_Transmission+0xa8>
			scoreReset = 1;
 3da:	81 e0       	ldi	r24, 0x01	; 1
 3dc:	80 93 06 01 	sts	0x0106, r24
 3e0:	02 c0       	rjmp	.+4      	; 0x3e6 <TickFct_Transmission+0xa8>
	unsigned char dataIn = 0;
	unsigned char dataOut = 0;

	switch(state){	//Transitions
		case TN_SMStart:
		state = TN_Wait;
 3e2:	c1 e0       	ldi	r28, 0x01	; 1
 3e4:	d0 e0       	ldi	r29, 0x00	; 0
		state = TN_SMStart;
		break;
	}

	return state;
}
 3e6:	ce 01       	movw	r24, r28
 3e8:	df 91       	pop	r29
 3ea:	cf 91       	pop	r28
 3ec:	08 95       	ret

000003ee <transmit_data>:
	return SPDR;
}

void transmit_data(unsigned char data){
	int i;
	for(i = 7; i >= 0; --i){
 3ee:	27 e0       	ldi	r18, 0x07	; 7
 3f0:	30 e0       	ldi	r19, 0x00	; 0
		PORTD = 0x08;
 3f2:	58 e0       	ldi	r21, 0x08	; 8
		PORTD |= ((data >> i) & 0x01);
 3f4:	e8 2f       	mov	r30, r24
 3f6:	f0 e0       	ldi	r31, 0x00	; 0
}

void transmit_data(unsigned char data){
	int i;
	for(i = 7; i >= 0; --i){
		PORTD = 0x08;
 3f8:	5b b9       	out	0x0b, r21	; 11
		PORTD |= ((data >> i) & 0x01);
 3fa:	4b b1       	in	r20, 0x0b	; 11
 3fc:	bf 01       	movw	r22, r30
 3fe:	02 2e       	mov	r0, r18
 400:	02 c0       	rjmp	.+4      	; 0x406 <transmit_data+0x18>
 402:	75 95       	asr	r23
 404:	67 95       	ror	r22
 406:	0a 94       	dec	r0
 408:	e2 f7       	brpl	.-8      	; 0x402 <transmit_data+0x14>
 40a:	96 2f       	mov	r25, r22
 40c:	91 70       	andi	r25, 0x01	; 1
 40e:	94 2b       	or	r25, r20
 410:	9b b9       	out	0x0b, r25	; 11
		PORTD |= 0x04;
 412:	5a 9a       	sbi	0x0b, 2	; 11
	return SPDR;
}

void transmit_data(unsigned char data){
	int i;
	for(i = 7; i >= 0; --i){
 414:	21 50       	subi	r18, 0x01	; 1
 416:	31 09       	sbc	r19, r1
 418:	78 f7       	brcc	.-34     	; 0x3f8 <transmit_data+0xa>
		PORTD = 0x08;
		PORTD |= ((data >> i) & 0x01);
		PORTD |= 0x04;
	}
	PORTD |=0x02;
 41a:	59 9a       	sbi	0x0b, 1	; 11
	PORTD = 0x00;
 41c:	1b b8       	out	0x0b, r1	; 11
 41e:	08 95       	ret

00000420 <writeScore>:
}

void writeScore(unsigned char givenNum){
	unsigned char data = 0x00;
	switch(givenNum){
 420:	90 e0       	ldi	r25, 0x00	; 0
 422:	8a 30       	cpi	r24, 0x0A	; 10
 424:	91 05       	cpc	r25, r1
 426:	b0 f4       	brcc	.+44     	; 0x454 <writeScore+0x34>
 428:	fc 01       	movw	r30, r24
 42a:	ea 5b       	subi	r30, 0xBA	; 186
 42c:	ff 4f       	sbci	r31, 0xFF	; 255
 42e:	f4 c0       	rjmp	.+488    	; 0x618 <__tablejump2__>
		case 0:
		data = 0x7E;
		break;
		case 1:
		data = 0x48;
 430:	88 e4       	ldi	r24, 0x48	; 72
 432:	13 c0       	rjmp	.+38     	; 0x45a <writeScore+0x3a>
		break;
		case 2:
		data = 0x3D;
 434:	8d e3       	ldi	r24, 0x3D	; 61
		break;
 436:	11 c0       	rjmp	.+34     	; 0x45a <writeScore+0x3a>
		case 3:
		data = 0x6D;
 438:	8d e6       	ldi	r24, 0x6D	; 109
		break;
 43a:	0f c0       	rjmp	.+30     	; 0x45a <writeScore+0x3a>
		case 4:
		data = 0x4B;
 43c:	8b e4       	ldi	r24, 0x4B	; 75
		break;
 43e:	0d c0       	rjmp	.+26     	; 0x45a <writeScore+0x3a>
		case 5:
		data = 0x67;
 440:	87 e6       	ldi	r24, 0x67	; 103
		break;
 442:	0b c0       	rjmp	.+22     	; 0x45a <writeScore+0x3a>
		case 6:
		data = 0x77;
 444:	87 e7       	ldi	r24, 0x77	; 119
		break;
 446:	09 c0       	rjmp	.+18     	; 0x45a <writeScore+0x3a>
		case 7:
		data = 0x4C;
 448:	8c e4       	ldi	r24, 0x4C	; 76
		break;
 44a:	07 c0       	rjmp	.+14     	; 0x45a <writeScore+0x3a>
		case 8:
		data = 0x7F;
 44c:	8f e7       	ldi	r24, 0x7F	; 127
		break;
 44e:	05 c0       	rjmp	.+10     	; 0x45a <writeScore+0x3a>
		case 9:
		data = 0x4F;
 450:	8f e4       	ldi	r24, 0x4F	; 79
		break;
 452:	03 c0       	rjmp	.+6      	; 0x45a <writeScore+0x3a>
		default:
		data = 0x00;
 454:	80 e0       	ldi	r24, 0x00	; 0
		break;
 456:	01 c0       	rjmp	.+2      	; 0x45a <writeScore+0x3a>

void writeScore(unsigned char givenNum){
	unsigned char data = 0x00;
	switch(givenNum){
		case 0:
		data = 0x7E;
 458:	8e e7       	ldi	r24, 0x7E	; 126
		default:
		data = 0x00;
		break;
	}

	transmit_data((~data));
 45a:	80 95       	com	r24
 45c:	c8 cf       	rjmp	.-112    	; 0x3ee <transmit_data>
 45e:	08 95       	ret

00000460 <TickFct_Score>:
	}

	return state;
}

int TickFct_Score(int state){
 460:	1f 93       	push	r17
 462:	cf 93       	push	r28
 464:	df 93       	push	r29
 466:	ec 01       	movw	r28, r24

	static unsigned char scoreTotal = 0;
	
	switch(state){
 468:	00 97       	sbiw	r24, 0x00	; 0
 46a:	31 f1       	breq	.+76     	; 0x4b8 <TickFct_Score+0x58>
 46c:	01 97       	sbiw	r24, 0x01	; 1
 46e:	19 f0       	breq	.+6      	; 0x476 <TickFct_Score+0x16>
		}

		break;

		default:
		state = SE_SMStart;
 470:	c0 e0       	ldi	r28, 0x00	; 0
 472:	d0 e0       	ldi	r29, 0x00	; 0
 474:	23 c0       	rjmp	.+70     	; 0x4bc <TickFct_Score+0x5c>
		break;
		
		case SE_Wait:
		state = SE_Wait;

		writeScore(scoreTotal);
 476:	10 91 04 01 	lds	r17, 0x0104
 47a:	81 2f       	mov	r24, r17
 47c:	d1 df       	rcall	.-94     	; 0x420 <writeScore>

		if(scoreFlag&&scoreTotal < 5){
 47e:	80 91 08 01 	lds	r24, 0x0108
 482:	88 23       	and	r24, r24
 484:	39 f0       	breq	.+14     	; 0x494 <TickFct_Score+0x34>
 486:	15 30       	cpi	r17, 0x05	; 5
 488:	28 f4       	brcc	.+10     	; 0x494 <TickFct_Score+0x34>
			scoreFlag = 0;
 48a:	10 92 08 01 	sts	0x0108, r1
			scoreTotal++;
 48e:	1f 5f       	subi	r17, 0xFF	; 255
 490:	10 93 04 01 	sts	0x0104, r17
		}

		if(scoreTotal == 5){
 494:	80 91 04 01 	lds	r24, 0x0104
 498:	85 30       	cpi	r24, 0x05	; 5
 49a:	29 f4       	brne	.+10     	; 0x4a6 <TickFct_Score+0x46>
			winFlag = 1;
 49c:	81 e0       	ldi	r24, 0x01	; 1
 49e:	80 93 07 01 	sts	0x0107, r24
			resetFlag = 1;
 4a2:	80 93 0c 01 	sts	0x010C, r24
		}

		if(scoreReset){
 4a6:	80 91 06 01 	lds	r24, 0x0106
 4aa:	88 23       	and	r24, r24
 4ac:	39 f0       	breq	.+14     	; 0x4bc <TickFct_Score+0x5c>
			scoreTotal = 0;
 4ae:	10 92 04 01 	sts	0x0104, r1
			scoreReset = 0;
 4b2:	10 92 06 01 	sts	0x0106, r1
 4b6:	02 c0       	rjmp	.+4      	; 0x4bc <TickFct_Score+0x5c>

	static unsigned char scoreTotal = 0;
	
	switch(state){
		case SE_SMStart:
		state = SE_Wait;
 4b8:	c1 e0       	ldi	r28, 0x01	; 1
 4ba:	d0 e0       	ldi	r29, 0x00	; 0
		state = SE_SMStart;
		break;
	}

	return state;
}
 4bc:	ce 01       	movw	r24, r28
 4be:	df 91       	pop	r29
 4c0:	cf 91       	pop	r28
 4c2:	1f 91       	pop	r17
 4c4:	08 95       	ret

000004c6 <main>:
//========================================MAIN===============================================//

int main(void)
{
	
	DDRA = 0x00; PORTA = 0xFF;	//Input Port, joystick and buttons.
 4c6:	11 b8       	out	0x01, r1	; 1
 4c8:	8f ef       	ldi	r24, 0xFF	; 255
 4ca:	82 b9       	out	0x02, r24	; 2
	DDRB = 0xFF; PORTB = 0x00;	//Output Port, test output to led.
 4cc:	84 b9       	out	0x04, r24	; 4
 4ce:	15 b8       	out	0x05, r1	; 5
	DDRD = 0xFF; PORTD = 0x00;
 4d0:	8a b9       	out	0x0a, r24	; 10
 4d2:	1b b8       	out	0x0b, r1	; 11
	DDRC = 0xFF; PORTC = 0x00;	//C0 is motor.
 4d4:	87 b9       	out	0x07, r24	; 7
 4d6:	18 b8       	out	0x08, r1	; 8

	unsigned char i=0;
	tasks[i].state = JS_SMStart;
 4d8:	e4 e1       	ldi	r30, 0x14	; 20
 4da:	f1 e0       	ldi	r31, 0x01	; 1
 4dc:	11 82       	std	Z+1, r1	; 0x01
 4de:	10 82       	st	Z, r1
	tasks[i].period = periodJoystick;
 4e0:	8a e0       	ldi	r24, 0x0A	; 10
 4e2:	90 e0       	ldi	r25, 0x00	; 0
 4e4:	a0 e0       	ldi	r26, 0x00	; 0
 4e6:	b0 e0       	ldi	r27, 0x00	; 0
 4e8:	82 83       	std	Z+2, r24	; 0x02
 4ea:	93 83       	std	Z+3, r25	; 0x03
 4ec:	a4 83       	std	Z+4, r26	; 0x04
 4ee:	b5 83       	std	Z+5, r27	; 0x05
	tasks[i].elapsedTime = tasks[i].period;
 4f0:	86 83       	std	Z+6, r24	; 0x06
 4f2:	97 83       	std	Z+7, r25	; 0x07
 4f4:	a0 87       	std	Z+8, r26	; 0x08
 4f6:	b1 87       	std	Z+9, r27	; 0x09
	tasks[i].TickFct = &TickFct_Joystick;
 4f8:	8e e6       	ldi	r24, 0x6E	; 110
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	93 87       	std	Z+11, r25	; 0x0b
 4fe:	82 87       	std	Z+10, r24	; 0x0a
	i++;
	tasks[i].state = JP_SMStart;
 500:	15 86       	std	Z+13, r1	; 0x0d
 502:	14 86       	std	Z+12, r1	; 0x0c
	tasks[i].period = periodJump;
 504:	8e e1       	ldi	r24, 0x1E	; 30
 506:	90 e0       	ldi	r25, 0x00	; 0
 508:	a0 e0       	ldi	r26, 0x00	; 0
 50a:	b0 e0       	ldi	r27, 0x00	; 0
 50c:	86 87       	std	Z+14, r24	; 0x0e
 50e:	97 87       	std	Z+15, r25	; 0x0f
 510:	a0 8b       	std	Z+16, r26	; 0x10
 512:	b1 8b       	std	Z+17, r27	; 0x11
	tasks[i].elapsedTime = tasks[i].period;
 514:	82 8b       	std	Z+18, r24	; 0x12
 516:	93 8b       	std	Z+19, r25	; 0x13
 518:	a4 8b       	std	Z+20, r26	; 0x14
 51a:	b5 8b       	std	Z+21, r27	; 0x15
	tasks[i].TickFct = &TickFct_Jump;
 51c:	2f e9       	ldi	r18, 0x9F	; 159
 51e:	30 e0       	ldi	r19, 0x00	; 0
 520:	37 8b       	std	Z+23, r19	; 0x17
 522:	26 8b       	std	Z+22, r18	; 0x16
	i++;
	tasks[i].state = CH_SMStart;
 524:	11 8e       	std	Z+25, r1	; 0x19
 526:	10 8e       	std	Z+24, r1	; 0x18
	tasks[i].period = periodCrouch;
 528:	82 8f       	std	Z+26, r24	; 0x1a
 52a:	93 8f       	std	Z+27, r25	; 0x1b
 52c:	a4 8f       	std	Z+28, r26	; 0x1c
 52e:	b5 8f       	std	Z+29, r27	; 0x1d
	tasks[i].elapsedTime = tasks[i].period;
 530:	86 8f       	std	Z+30, r24	; 0x1e
 532:	97 8f       	std	Z+31, r25	; 0x1f
 534:	a0 a3       	std	Z+32, r26	; 0x20
 536:	b1 a3       	std	Z+33, r27	; 0x21
	tasks[i].TickFct = &TickFct_Crouch;
 538:	2e e8       	ldi	r18, 0x8E	; 142
 53a:	30 e0       	ldi	r19, 0x00	; 0
 53c:	33 a3       	std	Z+35, r19	; 0x23
 53e:	22 a3       	std	Z+34, r18	; 0x22
	i++;
	tasks[i].state = RT_SMStart;
 540:	15 a2       	std	Z+37, r1	; 0x25
 542:	14 a2       	std	Z+36, r1	; 0x24
	tasks[i].period = periodReset;
 544:	86 a3       	std	Z+38, r24	; 0x26
 546:	97 a3       	std	Z+39, r25	; 0x27
 548:	a0 a7       	std	Z+40, r26	; 0x28
 54a:	b1 a7       	std	Z+41, r27	; 0x29
	tasks[i].elapsedTime = tasks[i].period;
 54c:	82 a7       	std	Z+42, r24	; 0x2a
 54e:	93 a7       	std	Z+43, r25	; 0x2b
 550:	a4 a7       	std	Z+44, r26	; 0x2c
 552:	b5 a7       	std	Z+45, r27	; 0x2d
	tasks[i].TickFct = &TickFct_Reset;
 554:	20 eb       	ldi	r18, 0xB0	; 176
 556:	30 e0       	ldi	r19, 0x00	; 0
 558:	37 a7       	std	Z+47, r19	; 0x2f
 55a:	26 a7       	std	Z+46, r18	; 0x2e
	i++;
	tasks[i].state = TN_SMStart;
 55c:	11 aa       	std	Z+49, r1	; 0x31
 55e:	10 aa       	std	Z+48, r1	; 0x30
	tasks[i].period = periodTransmission;
 560:	41 e0       	ldi	r20, 0x01	; 1
 562:	50 e0       	ldi	r21, 0x00	; 0
 564:	60 e0       	ldi	r22, 0x00	; 0
 566:	70 e0       	ldi	r23, 0x00	; 0
 568:	42 ab       	std	Z+50, r20	; 0x32
 56a:	53 ab       	std	Z+51, r21	; 0x33
 56c:	64 ab       	std	Z+52, r22	; 0x34
 56e:	75 ab       	std	Z+53, r23	; 0x35
	tasks[i].elapsedTime = tasks[i].period;
 570:	46 ab       	std	Z+54, r20	; 0x36
 572:	57 ab       	std	Z+55, r21	; 0x37
 574:	60 af       	std	Z+56, r22	; 0x38
 576:	71 af       	std	Z+57, r23	; 0x39
	tasks[i].TickFct = &TickFct_Transmission;
 578:	2f e9       	ldi	r18, 0x9F	; 159
 57a:	31 e0       	ldi	r19, 0x01	; 1
 57c:	33 af       	std	Z+59, r19	; 0x3b
 57e:	22 af       	std	Z+58, r18	; 0x3a
	i++;
	tasks[i].state = MR_SMStart;
 580:	15 ae       	std	Z+61, r1	; 0x3d
 582:	14 ae       	std	Z+60, r1	; 0x3c
	tasks[i].period = periodMotor;
 584:	80 93 52 01 	sts	0x0152, r24
 588:	90 93 53 01 	sts	0x0153, r25
 58c:	a0 93 54 01 	sts	0x0154, r26
 590:	b0 93 55 01 	sts	0x0155, r27
	tasks[i].elapsedTime = tasks[i].period;
 594:	80 93 56 01 	sts	0x0156, r24
 598:	90 93 57 01 	sts	0x0157, r25
 59c:	a0 93 58 01 	sts	0x0158, r26
 5a0:	b0 93 59 01 	sts	0x0159, r27
	tasks[i].TickFct = &TickFct_Motor;
 5a4:	21 ec       	ldi	r18, 0xC1	; 193
 5a6:	30 e0       	ldi	r19, 0x00	; 0
 5a8:	30 93 5b 01 	sts	0x015B, r19
 5ac:	20 93 5a 01 	sts	0x015A, r18
	i++;
	tasks[i].state = SE_SMStart;
 5b0:	10 92 5d 01 	sts	0x015D, r1
 5b4:	10 92 5c 01 	sts	0x015C, r1
	tasks[i].period = periodScore;
 5b8:	80 93 5e 01 	sts	0x015E, r24
 5bc:	90 93 5f 01 	sts	0x015F, r25
 5c0:	a0 93 60 01 	sts	0x0160, r26
 5c4:	b0 93 61 01 	sts	0x0161, r27
	tasks[i].elapsedTime = tasks[i].period;
 5c8:	80 93 62 01 	sts	0x0162, r24
 5cc:	90 93 63 01 	sts	0x0163, r25
 5d0:	a0 93 64 01 	sts	0x0164, r26
 5d4:	b0 93 65 01 	sts	0x0165, r27
	tasks[i].TickFct = &TickFct_Score;
 5d8:	80 e3       	ldi	r24, 0x30	; 48
 5da:	92 e0       	ldi	r25, 0x02	; 2
 5dc:	90 93 67 01 	sts	0x0167, r25
 5e0:	80 93 66 01 	sts	0x0166, r24
		_avr_timer_cntcurr = _avr_timer_M;
	}
}

void TimerSet(unsigned long M) {
	_avr_timer_M = M;
 5e4:	40 93 00 01 	sts	0x0100, r20
 5e8:	50 93 01 01 	sts	0x0101, r21
 5ec:	60 93 02 01 	sts	0x0102, r22
 5f0:	70 93 03 01 	sts	0x0103, r23
	_avr_timer_cntcurr = _avr_timer_M;
 5f4:	40 93 0f 01 	sts	0x010F, r20
 5f8:	50 93 10 01 	sts	0x0110, r21
 5fc:	60 93 11 01 	sts	0x0111, r22
 600:	70 93 12 01 	sts	0x0112, r23
	tasks[i].period = periodScore;
	tasks[i].elapsedTime = tasks[i].period;
	tasks[i].TickFct = &TickFct_Score;

	TimerSet(tasksPeriodGCD);
	TimerOn();
 604:	e2 dd       	rcall	.-1084   	; 0x1ca <TimerOn>
	ADC_init();
 606:	db dd       	rcall	.-1098   	; 0x1be <ADC_init>
	SPI_SlaveInit();
 608:	90 de       	rcall	.-736    	; 0x32a <SPI_SlaveInit>

	while (1)
	{
		while(!TimerFlag);
 60a:	80 91 13 01 	lds	r24, 0x0113
 60e:	88 23       	and	r24, r24
 610:	e1 f3       	breq	.-8      	; 0x60a <main+0x144>
		TimerFlag = 0;
 612:	10 92 13 01 	sts	0x0113, r1
	}
 616:	f9 cf       	rjmp	.-14     	; 0x60a <main+0x144>

00000618 <__tablejump2__>:
 618:	ee 0f       	add	r30, r30
 61a:	ff 1f       	adc	r31, r31
 61c:	00 24       	eor	r0, r0
 61e:	00 1c       	adc	r0, r0
 620:	0b be       	out	0x3b, r0	; 59
 622:	07 90       	elpm	r0, Z+
 624:	f6 91       	elpm	r31, Z
 626:	e0 2d       	mov	r30, r0
 628:	09 94       	ijmp

0000062a <_exit>:
 62a:	f8 94       	cli

0000062c <__stop_program>:
 62c:	ff cf       	rjmp	.-2      	; 0x62c <__stop_program>
